/**
Marker interface for Facets implementation of Superficial target.
*/
export interface Target{}
>interface Target
/**
* For passing state in and out of a simple {Target}.
*/
export type SimpleState=string|boolean|number
>type SimpleState
/** */
export interface TargetCoupler {
OK: interface TargetCoupler {
  /**
   * Called on update of the target constructed with the coupler.
   * @param state the updated state
   * @param {string} title identifies the target
   */
  targetStateUpdated?: (state: SimpleState, title: string) => void;
>targetStateUpdated
}
/**
Connects a textual target with client code.
*/
export interface TextualCoupler extends TargetCoupler{
>interface TextualCoupler extends TargetCoupler
  /**
  Sets initial state of the textual.
  */
  passText?:string;
>passText
  /**
  * Supply state for the target.
  * Must be implemented if no passText.
  * @param {string} title identifies the target
  * @returns {string} the state
  */
  getText?:(title:string)=>string;
>getText
  /**
  * Allows validation of changed target state
  * @param {string} text to validate
  * @param {string} title identifies the target
  * @returns {boolean} true if valid
  */
  isValidText?:(text: string, title: string)=>boolean;
>isValidText
}
/**
 Connects a toggling (boolean) target with client code.
 */
export interface TogglingCoupler extends TargetCoupler {
OK: interface TogglingCoupler extends TargetCoupler {
  /**
   Sets initial state of the toggling.
   */
  passSet: boolean;
OK: passSet: boolean;
}
/**
 Connects a numeric target with client code.
 */
export interface NumericCoupler extends TargetCoupler {
OK: interface NumericCoupler extends TargetCoupler {
  /**
   Sets initial state of the numeric.
   */
  passValue: number;
OK: passValue: number;
  /**
   Minimum state of the numeric.
   */
  min: number;
OK: min: number;
  /**
   Maximum state of the numeric.
   */
  max: number;
OK: max: number;
}
/**
 Connects an indexing (list-type) target with client code.
 */
export interface IndexingCoupler extends TargetCoupler{
>interface IndexingCoupler extends TargetCoupler
  /**
   Sets initial state of the indexing (the index into its contents).
   */
  passIndex:number;
>passIndex
  /**
   * Get the contents to be indexed
   * @param {string} title identifies the target
   * @returns {any[]}
   */
  getIndexables: (title: string) => any[];
>getIndexables
  /**
   * Get strings to represent the indexable contents in the UI
   * @param {string} title identifies the target
   * @returns {string[]}
   */
  getUiSelectables: (title: string) => string[];
>getUiSelectables
}
/**
 * Current values exposed by the indexing
 */
interface IndexingState {
OK: interface IndexingState {
  /**
   * As last created by IndexingCoupler.getUiSelectables
   */
  uiSelectables: string[];
OK: uiSelectables: string[];
  /**
   * The result of the current index into the indexables.
   */
  indexed: any;
OK: indexed: any;
}
/**
 * Defines a target that wraps content selected with an indexing.
 */
export interface IndexingFramePolicy {
OK: interface IndexingFramePolicy {
  /**
   * Title for the wrapping target.
   */
  frameTitle: string;
OK: frameTitle: string;
  /**
   * Title for the wrapped indexing.
   */
  indexingTitle: string;
OK: indexingTitle: string;
  /**
   * Get current items to be indexed.
   */
  getIndexables: () => any[];
OK: getIndexables: () => any[];
  /**
   * Supply strings to expose the content in the UI.
   * Analogue of IndexingCoupler function. 
   * @param {any[]} content current state of content
   * @returns {string[]}
   */
  getUiSelectables: () => string[];
OK: getUiSelectables: () => string[];
  /**
   * Create Targets exposing content independent of the indexing state
   * @returns {Target[]}
   */
  newIndexingTargets?: () => Target[];
>newIndexingTargets
  /**
   * Provides for supplying different targets
   * @param indexed selected with the indexing
   */
  newIndexedTitle: (indexed: any) => string;
>newIndexedTitle
  /**
   * Create Targets exposing the indexed content
   * @param indexed selected with the indexing
   * @param title from {newIndexedTitle}
   * @returns {Target[]}
   */
  newIndexedTargets: (indexed: any, indexedTitle: string) => Target[];
>newIndexedTargets
}
/**
* Constructs a new Superficial application core.
* @param {boolean} trace
* @returns {Facets}
*/
export interface Times {
>interface Times 
  /** */
  doTime: boolean;
OK: doTime: boolean;
  /** */
  setResetWait(millis: number): void;
>setResetWait
  /** */
  elapsed(): number;
OK: elapsed(): number;
  /**
   * Print {@link #elapsed()} followed by the message.
   * @param {string} msg
   */
  traceElapsed(msg: string): void;
OK: traceElapsed(msg: string): void;
}
/**
* A Superficial application core.
*/
export interface Facets{
>interface Facets
  /** */
  times: Times;
OK: times: Times;
  /** */
  doTrace: boolean;
OK: doTrace: boolean;
  /** */
  identity():any;
>identity
  /**
   *
   * @param {string} title identifies the target or its targeter
   * @param {TextualCoupler} coupler connects the target to client code
   * @returns textual {Target}
   */
  newTextualTarget(title:string,coupler:TextualCoupler):Target;
>newTextualTarget
  /** */
  newTogglingTarget(title: string, c: TogglingCoupler): Target;
>newTogglingTarget
  /** */
  newNumericTarget(title: string, coupler: NumericCoupler): Target;
>newNumericTarget
  /** */
  newTriggerTarget(title: string, coupler: TargetCoupler): Target;
>newTriggerTarget
  /**
  * Constructs a target containing others
  * @param {string} title for the target
  * @param {Target} members of the group
  * @returns group of {Target}s
  */
  newTargetGroup(title:string,...members:Target[]):Target;
>newTargetGroup
  /** */
  newIndexingTarget(title:string,coupler:IndexingCoupler):Target;
>newIndexingTarget
  /** */
  getIndexingState(title: string): IndexingState;
OK: getIndexingState(title: string): IndexingState;
  /** */
  newIndexingFrame(policy: IndexingFramePolicy): Target;
>newIndexingFrame
  /**
   * Constructs a tree of targeters using the initial target tree.
   * @param {Target} targetTree the root of the target tree
   */
  buildTargeterTree(targetTree:Target):void;
>buildTargeterTree
  /** */
  updateTargeterTree(): void;
OK: updateTargeterTree(): void;
  /**
   * Attach an internal facet to the targeter with the target title passed.
   * @param {string} title identifies the targeter
   * @param {(state) => void} facetUpdated callback to update the UI with the target state
   */
  attachFacet(title:string,facetUpdated:(state:SimpleState)=>void):void;
>attachFacet
  /**
   * Update the state of the target identified.
   * @param {string} title identifies the target
   * @param {SimpleState} update to update the target
   */
  updateTargetState(title:string,update:SimpleState):void;
>updateTargetState
  /**
   * Obtain the the state of the target identified.
   * @param {string} title identifies the target
   * @returns {SimpleState} the state
   */
  getTargetState(title:string):SimpleState;
>getTargetState
  /**
   * Notify the framework of an update and trigger a retargeting. 
   * @param {string} title identifies the target
   */
  notifyTargetUpdated(title: string): void;
OK: notifyTargetUpdated(title: string): void;
  /**
   * Update target and and trigger a retargeting. 
   * @param {string} title identifies the target
   * @param {SimpleState} update for target state
   */
  updateTargetWithNotify(title:string,update:SimpleState):void;
>updateTargetWithNotify
  /** */
  setTargetLive(title: string, live: boolean): void;
OK: setTargetLive(title: string, live: boolean): void;
  /** */
  isTargetLive(title: string): boolean;
OK: isTargetLive(title: string): boolean;
  /** */
  onRetargeted: ()=>void;
>onRetargeted
  /** */
  supplement:any;
>supplement
}
/** */
export function newInstance(trace:boolean):Facets;
>function newInstance